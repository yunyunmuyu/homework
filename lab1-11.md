                                    贪吃蛇游戏的设计，算法及创新玩法
一：定义一个二维数组，作为贪吃蛇的活动框架。如下面所示：
char map[12][12]=
{"************"
 "*XXXXH     *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "*          *"
 "************"
}
*代表了墙壁，当贪吃蛇碰上就会死亡。
H代表了蛇头，X代表了蛇身。

二:蛇的运动：
我们通过输入四个之母来控制蛇的运动。
W:蛇向上运动；
A:蛇往右运动；
D:蛇往左运动；
S:蛇往下运动；
为了实现这项功能；我们通过构造一个坐标结构数组来帮助我们实现，如下：
struct point{
 int x;
 int y;
 }points[5]={
 	1,1,
 	2,1,
 	3,1,
 	4,1,
 	5,1,
 };
 数组point的五个元素分别表示了贪吃蛇蛇头和蛇身初始的位置；
 定义好之后，要实现蛇的运动就比较简单了，我们通过改变蛇的各个点的坐标来实现运动：
 void snakemove(char c)
 {
 	int i;
 	for(i=0;i<4;++i)
 	{
 		points[i].x=points[i+1].x;
 		points[i].y=points[i+1].y;
	 }
   switch(c){
   	case 'A':points[4].x--;    break；   
	case 'D' : points[4].x++;  	break;
	case 'S' :points[4].y++;   break;
	case 'W' :points[4].y--;  break ;
	   }
}
三：实现游戏结束：
我们可以读取贪吃蛇的下一步运动，并通过判断是否会碰上*来决定游戏能否进行下去：
int  gameover(char c){
	switch(c){
   	case 'A':x=points[4].x-1,y=points[4].y;    break；   
	case 'D' :x=points[4].x+1; y=points[4].y;  	break;
	case 'S' :y=points[4].y+1; x=points[4].x  ;break;
	case 'W' :y=points[4].y-1; x=points[4].x ;break ;
	   }
	if(map[y][x]=='*')
	  return -1;
	  else return 1;
}
如果返回来的-1；游戏就会结束了。

创新玩法：我们可以增加一条智能蛇，通过rank等函数来控制它的行为。该智能蛇将会与我们的蛇竞争食物和空间。增加游戏的趣味性。